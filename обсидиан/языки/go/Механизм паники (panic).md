#go
#### `defer`, `panic` и `recover`

В Go существует механизм паники, который позволяет перехватывать и обрабатывать критические ошибки. Для этого используются конструкции `defer` и встроенная функция `recover`.

### `defer`

`defer` — это концепция, позволяющая выполнять блоки кода при выходе из функции. Например, это удобно для закрытия файлов по завершении работы с ними. `defer` выполняется даже в случае паники, что аналогично конструкторам/менеджерам контекста в других языках (например, `try_with_resources` в Java, `with` в Python).

```go
func foo() {
    // Паникуем
    panic("unexpected!")
}

func main() {
    // Выполняется после срабатывания паники
    defer func() {
        if r := recover(); r != nil {
            // Обработка паники, в переменной r будет лежать строка "unexpected!"
        }
    }()
    
    // Внутри foo срабатывает паника
    foo()
}
```

#### Отличие паники от исключений

Паника в Go отличается от механизма исключений в других языках. Исключения обычно ожидают, что они будут перехвачены обработчиком исключений выше по стеку вызовов. Паника же не всегда перехватывается. Если при возвращении управления по стеку функции не вызовется `recover()`, то программа завершит свою работу с ошибкой.

#### Пример паники при делении на 0

```go
func div(a, b int) int {
    return a / b
}

func main() {
    // Вызов div(10, 0) приведёт к завершению работы программы с ошибкой
    div(10, 0)
}
```

Ошибка: `panic: runtime error: integer divide by zero`

#### Пример паники при доступе к пустому массиву

```go
func main() {
    var a []int
    a[0] = 7 // Здесь возникнет паника
}
```

Ошибка: `panic: runtime error: index out of range [0] with length 0`

#### Использование `panic` и `recover`

Аварийную ситуацию можно создать самостоятельно, вызвав функцию `panic` с параметром любого типа. По умолчанию паника будет идти вверх по стеку и завершать все функции, пока не завершит функцию `main`, а вместе с ней и весь процесс. К использованию функции `panic()` следует относиться с осторожностью. 

`recover` — функция, которая позволяет восстановить выполнение программы в случае паники. Если на момент вызова `recover` произошла аварийная ситуация, то `recover` завершает её и возвращает значение ошибки (аргумент при вызове `panic`). Если аварийной ситуации не было, `recover` ничего не делает и возвращает `nil`.

```go
func foo() {
    // Паникуем
    panic("unexpected!")
}

func main() {
    // Выполняется при завершении main
    defer func() {
        // Вызываем recover и сравниваем результат с nil
        if r := recover(); r != nil {
            fmt.Println(r) // Выведет "unexpected!"
        }
    }()
    foo() // Внутри foo срабатывает паника
    fmt.Println("Вы не увидите это сообщение, так как в foo возникла паника")
}
```
[Go](GO)