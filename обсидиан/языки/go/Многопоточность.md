#go 
#### Модель CSP

Многопоточность в Go реализована согласно модели **CSP (Communicating Sequential Processes).** В такой модели программа представляет собой множество одновременно работающих подзадач, которые общаются между собой с помощью каналов связи. 

#### Основные элементы многопоточности в Go

1. **Горутины (goroutine)**
2. **Каналы (channel)**

#### Горутины

Горутины — это легковесные потоки, которые занимают гораздо меньше памяти, чем потоки операционной системы. Среда выполнения Go может выполнять несколько горутин на одном потоке ОС и быстро переключаться с одной горутины на другую благодаря их малому размеру.

Первоначально в Go была реализована кооперативная многозадачность: пока код в горутине сам не передаст управление (например, попытавшись выполнить блокирующую операцию), забрать управление у этой горутины невозможно. С версии 1.14 планировщик стал в том числе вытесняющим. Вытесняющий планировщик самостоятельно распределяет процессорное время между горутинами.

Пример создания горутины:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    go sayHello()
    time.Sleep(1 * time.Second)
}

func sayHello() {
    fmt.Println("Hello, World!")
}
```

#### Каналы

Каналы — это второй ключевой элемент многопоточности в Go. Каналы позволяют горутинам обмениваться данными и синхронизировать свою работу. Одна горутина может записать данные в канал, а другая горутина — прочитать их.

Пример использования каналов:

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int)

    go func() {
        ch <- 42
    }()

    value := <-ch
    fmt.Println(value)
}
```

#### Примитивы синхронизации

Кроме горутин и каналов, стандартная библиотека Go предоставляет дополнительные примитивы синхронизации потоков, такие как `sync.Mutex`, `sync.WaitGroup` и другие.

Пример использования `sync.WaitGroup`:

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup
    wg.Add(2)

    go func() {
        defer wg.Done()
        fmt.Println("Горутина 1")
    }()

    go func() {
        defer wg.Done()
        fmt.Println("Горутина 2")
    }()

    wg.Wait()
    fmt.Println("Все горутины завершены")
}
```

#### Заключение

Горутины, каналы и примитивы синхронизации делают язык Go удобным инструментом для создания многопоточных программ и различных сервисов.

#### Полезные ссылки

- [Go Wiki: Concurrency](https://golang.org/doc/effective_go.html#concurrency)
- [A Tour of Go: Concurrency](https://tour.golang.org/concurrency/1)
- [Go by Example: Goroutines](https://gobyexample.com/goroutines)
- [Go by Example: Channels](https://gobyexample.com/channels)
- [Effective Go: Concurrency](https://golang.org/doc/effective_go.html#concurrency)
- [Go](GO)