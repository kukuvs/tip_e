#java
### Многопоточность

1. **Создание и запуск потоков**
```java
// Реализация интерфейса Runnable
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

// Создание и запуск потока
Thread thread = new Thread(new MyRunnable());
thread.start();
```
В Java можно создать поток двумя способами: реализовав интерфейс [Runnable](https://ru.wikipedia.org/wiki/Runnable) или унаследовав класс [Thread](https://ru.wikipedia.org/wiki/Thread). Метод `run` содержит код, который будет выполняться в новом потоке. Метод `start` запускает поток.

2. **Синхронизация**
```java
class Counter {
    private int count = 0;

    // Синхронизированный метод для увеличения счетчика
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

Counter counter = new Counter();

// Запуск нескольких потоков
Thread t1 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
});

Thread t2 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
});

t1.start();
t2.start();
t1.join();
t2.join();

System.out.println("Count: " + counter.getCount());
```
Синхронизация предотвращает одновременный доступ нескольких потоков к критической секции кода, чтобы избежать проблем [состояния гонки](https://ru.wikipedia.org/wiki/Состояние_гонки). Ключевое слово `synchronized` используется для создания синхронизированных методов.

3. **Мьютексы (Locks)**
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class CounterWithLock {
    private int count = 0;
    private Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        return count;
    }
}

CounterWithLock counter = new CounterWithLock();

Thread t1 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
});

Thread t2 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
});

t1.start();
t2.start();
t1.join();
t2.join();

System.out.println("Count: " + counter.getCount());
```
[Мьютексы](https://ru.wikipedia.org/wiki/Мьютекс) (Locks) предоставляют более гибкий механизм синхронизации по сравнению с ключевым словом `synchronized`. Они позволяют использовать блокировку и разблокировку ресурсов вручную.

### Асинхронность

1. **Использование класса Future**
```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        return 123;
    }
}

ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(new MyCallable());

try {
    Integer result = future.get();
    System.out.println("Result: " + result);
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
} finally {
    executor.shutdown();
}
```
Класс [Future](https://ru.wikipedia.org/wiki/Future) используется для представления результата асинхронной операции. Метод `get` блокирует выполнение до получения результата. Это полезно, когда нужно дождаться завершения долгой задачи, не блокируя основной поток.

2. **Использование класса CompletableFuture**
```java
import java.util.concurrent.CompletableFuture;

CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    return 123;
});

future.thenAccept(result -> {
    System.out.println("Result: " + result);
});
```
[CompletableFuture](https://ru.wikipedia.org/wiki/CompletableFuture) предоставляет более мощные возможности для создания асинхронного кода и цепочек выполнения. Он позволяет комбинировать несколько асинхронных задач и обрабатывать их результаты без блокировки.

### Решение проблем многопоточности

1. **Гонки (Race Conditions)**
```java
class SafeCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

SafeCounter counter = new SafeCounter();

// Запуск нескольких потоков
Thread t1 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
});

Thread t2 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
});

t1.start();
t2.start();
t1.join();
t2.join();

System.out.println("Count: " + counter.getCount());
```
Гонки (Race Conditions) возникают, когда несколько потоков одновременно обращаются к общим данным, что приводит к некорректному поведению программы. Синхронизация позволяет избежать этой проблемы, гарантируя, что только один поток может выполнять критическую секцию кода в одно и то же время.

2. **Взаимные блокировки (Deadlocks)**
```java
class Resource {
    private final String name;

    Resource(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public synchronized void use(Resource other) {
        System.out.println("Using " + this.name + " and " + other.getName());
    }
}

Resource res1 = new Resource("Resource1");
Resource res2 = new Resource("Resource2");

Thread t1 = new Thread(() -> {
    synchronized (res1) {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        res1.use(res2);
    }
});

Thread t2 = new Thread(() -> {
    synchronized (res2) {
        res2.use(res1);
    }
});

t1.start();
t2.start();
t1.join();
t2.join();
```
[Взаимные блокировки](https://ru.wikipedia.org/wiki/Взаимная_блокировка) (Deadlocks) происходят, когда два или более потока блокируют друг друга, ожидая освобождения ресурсов. Это приводит к бесконечному ожиданию. Решением может быть использование строгого порядка захвата ресурсов или использование `tryLock`.

### Современные библиотеки

1. **Использование ForkJoinPool**
```java
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

class SumTask extends RecursiveTask<Integer> {
    private final int[] array;
    private final int start, end;

    SumTask(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (end - start <= 10) {
            int sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            int mid = (start + end) / 2;
            SumTask leftTask = new SumTask(array, start, mid);
            SumTask rightTask = new SumTask(array, mid, end);
            leftTask.fork();
            return rightTask.compute() + leftTask.join();
        }
    }
}

ForkJoinPool pool = new ForkJoinPool();
int[] array = new int[100];
for (int i = 0; i < array.length; i++) {
    array[i] = i + 1;
}
SumTask task = new SumTask(array, 0, array.length);
int sum = pool.invoke(task);
System.out.println("Sum: " + sum);
```
[ForkJoinPool](https://ru.wikipedia.org/wiki/ForkJoinPool) предоставляет удобный способ распараллеливания задач. Он использует алгоритм "разделяй и властвуй", что позволяет эффективно распределять работу между потоками.

2. **Асинхронные операции с использованием CompletableFuture**
```java
import java.util.concurrent.CompletableFuture;

CompletableFuture.supplyAsync(() -> {
    return "Hello";
}).thenApply(result -> {
    return result + " World";
}).thenAccept(finalResult -> {
    System.out.println(finalResult);
});
```
`CompletableFuture` позволяет строить цепочки асинхронных операций и обрабатывать результаты. Это делает код более читаемым и управляемым, чем использование простого `Future`.

---
[[языки/java/Структура языка]]